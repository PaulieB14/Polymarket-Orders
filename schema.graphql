# Generic

type Global @entity {
  "ID is empty string, this is a singleton"
  id: ID!
  numConditions: Int!
  numOpenConditions: Int!
  numClosedConditions: Int!

  "Number of unique traders interacting with Polymarket"
  numTraders: BigInt!

  "Number of trades of any kind for all market makers"
  tradesQuantity: BigInt!
  "Number of purchases of shares from any market maker"
  buysQuantity: BigInt!
  "Number of sales of shares to any market maker"
  sellsQuantity: BigInt!

  "Global volume in USDC base units"
  collateralVolume: BigInt!
  "Global volume in USDC scaled by 10^6"
  scaledCollateralVolume: BigDecimal!
  "Global fees in USDC base units"
  collateralFees: BigInt!
  "Global fees in USDC scaled by 10^6"
  scaledCollateralFees: BigDecimal!

  "Global volume of share purchases in USDC base units"
  collateralBuyVolume: BigInt!
  "Global volume of share purchases in USDC scaled by 10^6"
  scaledCollateralBuyVolume: BigDecimal!
  "Global volume of share sales in USDC base units"
  collateralSellVolume: BigInt!
  "Global volume of share sales in USDC scaled by 10^6"
  scaledCollateralSellVolume: BigDecimal!
}

type Account @entity {
  "User address"
  id: ID!
  "Timestamp at which account first interacted with Polymarket"
  creationTimestamp: BigInt!
  "Timestamp at which account most recently interacted with Polymarket"
  lastSeenTimestamp: BigInt!
  "Total volume of this user's trades in USDC base units"
  collateralVolume: BigInt!
  "Total number of trades performed by this user"
  numTrades: BigInt!
  "Total volume of this user's trades in USDC scaled by 10^6"
  scaledCollateralVolume: BigDecimal!
  "Timestamp of last Buy or Sell transaction"
  lastTradedTimestamp: BigInt!
  "Profit generated from fpmm and orderbook trades, merges and redemptions"
  profit: BigInt!
  "Realized profit in USDC scaled by 10^6"
  scaledProfit: BigDecimal!
}

type Collateral @entity {
  "Token address"
  id: ID!
  name: String!
  symbol: String!
  decimals: Int!
}

# Conditional Tokens

type Condition @entity {
  id: ID!
  "Address which can resolve this condition"
  oracle: Bytes!
  "Question ID which corresponds to this condition"
  questionId: Bytes!
  "Number of possible outcomes for this condition"
  outcomeSlotCount: Int!
  "Timestamp at which this condition was resolved"
  resolutionTimestamp: BigInt
  "Fraction of collateral assigned to each outcome"
  payouts: [BigDecimal!]
  payoutNumerators: [BigInt!]
  payoutDenominator: BigInt
  "Hash of the resolution transaction"
  resolutionHash: Bytes
}

# Exchange OrderFilled event stored directly
type OrderFilledEvent @entity {
  "Transaction hash + Order hash"
  id: ID!
  "Transaction hash"
  transactionHash: Bytes!
  "Timestamp at which filled occurred"
  timestamp: BigInt!
  orderHash: Bytes!
  "Addresses of the maker and the taker"
  maker: Account!
  taker: Account!
  "Maker assetId"
  makerAssetId: String!
  "Taker assetId"
  takerAssetId: String!
  "Maker amount filled"
  makerAmountFilled: BigInt!
  "Taker amount filled"
  takerAmountFilled: BigInt!
  "Fee paid by the order maker"
  fee: BigInt!
}

# Enriched OrderFilled event with price, size and side added
type EnrichedOrderFilled @entity {
  "Transaction hash + Order hash"
  id: ID!
  "Transaction hash"
  transactionHash: Bytes!
  "Timestamp at which transaction occurred"
  timestamp: BigInt!
  "Addresses of the maker and the taker"
  maker: Account!
  taker: Account!
  "Order hash"
  orderHash: Bytes!
  "Market/CTF Token ID which the transaction is interacting with"
  market: Orderbook!
  "Buy or Sell transaction"
  side: TradeType!
  "Amount of collateral in trade"
  size: BigInt!
  "Price of the conditional token"
  price: BigDecimal!
}

# Collection of EnrichedOrderFilled trades
type Orderbook @entity {
  "Token Id"
  id: ID!
  "Number of trades of any kind against this order book"
  tradesQuantity: BigInt!
  "Number of purchases of shares from this order book"
  buysQuantity: BigInt!
  "Number of sales of shares to this order book"
  sellsQuantity: BigInt!
  "Market volume in terms of the underlying collateral value"
  collateralVolume: BigInt!
  "Volume scaled by the number of decimals of collateralToken"
  scaledCollateralVolume: BigDecimal!
  "Global volume of share purchases in USDC base units"
  collateralBuyVolume: BigInt!
  "Global volume of share purchases in USDC scaled by 10^6"
  scaledCollateralBuyVolume: BigDecimal!
  "Global volume of share sales in USDC base units"
  collateralSellVolume: BigInt!
  "Global volume of share sales in USDC scaled by 10^6"
  scaledCollateralSellVolume: BigDecimal!
  "Timestamp of last day during which someone made a trade"
  lastActiveDay: BigInt!
}

# Exchange: all trades aggregated
type OrdersMatchedGlobal @entity {
  "ID is empty string, this is a singleton"
  id: ID!

  "Number of trades of any kind for all order books"
  tradesQuantity: BigInt!
  "Number of purchases of shares from any order book"
  buysQuantity: BigInt!
  "Number of sales of shares to any order book"
  sellsQuantity: BigInt!

  "Global volume in USDC base units"
  collateralVolume: BigDecimal!
  "Global volume in USDC scaled by 10^6"
  scaledCollateralVolume: BigDecimal!

  "Global volume of share purchases in USDC base units"
  collateralBuyVolume: BigDecimal!
  "Global volume of share purchases in USDC scaled by 10^6"
  scaledCollateralBuyVolume: BigDecimal!
  "Global volume of share sales in USDC base units"
  collateralSellVolume: BigDecimal!
  "Global volume of share sales in USDC scaled by 10^6"
  scaledCollateralSellVolume: BigDecimal!
}

enum TradeType {
  Buy
  Sell
}